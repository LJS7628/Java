package kr.ac.halla.lecture34;

import java.util.concurrent.Semaphore;

// 버전 1: 동기화 없이 단순히 숫자를 올리고 출력하는 스레드
class IncreaseThread implements Runnable {
    private String indentation;

    public IncreaseThread(String indentation) {
        this.indentation = indentation;
    }

    @Override
    public void run() {
        while (true) {
            int ccnt = Application.cnt;
            ccnt++;
            System.out.println(indentation + ccnt);
            Application.cnt = ccnt;
        }
    }
}

// 버전 2: 세마포어를 사용하여 임계 구역(Critical Section)을 보호하는 스레드
class IncreaseRunnable2 implements Runnable {
    @Override
    public void run() {
        try {
            for (int i = 0; i < 10000; i++) {
                // --- 임계 구역 진입 권한 획득 ---
                Application.s.acquire(); 
                
                int ccnt = Application.cnt;
                ccnt++;
                Application.cnt = ccnt;
                
                // --- 권한 반납 ---
                Application.s.release(); 
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class Application {
    // 여러 스레드가 동시에 접근할 공유 변수
    public static int cnt = 0;
    
    // 한 번에 하나의 스레드만 허용하는 세마포어 (이진 세마포어/뮤텍스 역할)
    public static Semaphore s = new Semaphore(1);

    public static void main(String[] args) throws InterruptedException {
        System.out.println("스레드 작업을 시작합니다...");

        // 5개의 스레드를 생성하여 동시에 실행
        Thread t1 = new Thread(new IncreaseRunnable2());
        Thread t2 = new Thread(new IncreaseRunnable2());
        Thread t3 = new Thread(new IncreaseRunnable2());
        Thread t4 = new Thread(new IncreaseRunnable2());
        Thread t5 = new Thread(new IncreaseRunnable2());

        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();

        // 모든 스레드가 작업을 마칠 때까지 충분히 대기 (5초)
        Thread.sleep(5000);

        // 결과 출력 (각 10,000번씩 5개 스레드이므로 50,000이 나와야 정상)
        System.out.println("최종 결과: " + cnt);
    }
}